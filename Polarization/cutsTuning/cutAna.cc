#ifndef __CINT__
#include <RooGlobalFunc.h>
#endif

#include "TLatex.h"
#include "RooRealVar.h"
#include "RooDataSet.h"
#include "RooGaussian.h"
#include "RooFitResult.h"
#include "RooLandau.h"
#include "RooChebychev.h"
#include "RooAddPdf.h"
#include "RooPlot.h"
#include "RooDataHist.h"
#include "RooVoigtian.h"
#include "RooCBShape.h"
#include "TCanvas.h"
#include "TROOT.h"

#include "TAxis.h"
#include "TH1.h"
#include "TTree.h"
#include "TFile.h"
#include "TH1D.h"
#include "TH1I.h"
#include "TCanvas.h"
#include "TLine.h"
#include "TMath.h"
#include "TVector3.h"
#include "vector.h"
#include "TString.h"
#include "iostream.h"
#include "fstream.h"
#include "TLegend.h"
#include "TStyle.h"

#include "fitPeak.cc"
#include "myStyle.h"
/*-----------------------------
This macro is used to get the "effSig" and "rejBkg" for every
cut individually. Need to include the macro "fitPeak.cc" 
to fit the Jpsi Mass distributions, and get the quantities we need.
-------------------------------*/
using namespace RooFit;

void cutAna( int CT )
{
	gROOT->Reset();
	Long_t nEntries, nData=0;
	const int nBin=3;

	/* ---------------------CT: Cut Type, num: value numbers for this cut------------------------ */
	char cutVar[100]; //cut Variables
	if(CT == 1) 
	{
		sprintf(cutVar,"mu_innerTrack_Hits");
		const int num=14;
	}
	if(CT == 2) 
	{
		sprintf(cutVar,"mu_pixeLayersTest");
		const int num=5;
	}
	if(CT == 3) 
	{
		sprintf(cutVar,"mu_nValidMuHits");
		const int num=10;
	}
	if(CT == 4) 
	{	
		sprintf(cutVar,"mu_innerTrack_chi2NDOF");
		const int num=16;
	}
	if(CT == 5) 
	{
		sprintf(cutVar,"mu_dxy");
		const int num=8;
	}
	if(CT == 6) 
	{
		sprintf(cutVar,"mu_dz");
		const int num=10;
	}
	if(CT == 7) 
	{
		sprintf(cutVar,"mu_globalTrack_chi2NDOF");
		const int num=10;
	}
	if(CT == 8) 
	{
		sprintf(cutVar,"vProb");
		const int num=10;
	}

	cout<<"selection cut: "<<cutVar<<endl;

	double cutVal[num]; //cut Values
	double nFoundSigRaw[nBin], nFoundBkgRaw[nBin];  // number of the signal and background with noCut
	double nFoundSig[nBin][num],nFoundBkg[nBin][num]; //num in the +-2sigma(signal) && out4sigma sideband(background)
	double nFoundSigFull[nBin][num],nFoundBkgFull[nBin][num];//num of signal yield && background
	double effSig[nBin][num], rejBkg[nBin][num];  //efficiency of keeping signal  && fraction of rejected background

	//define the selection Cut value
	for(int i=0; i<num; i++)
	{
		if(CT == 1) cutVal[i]=(double)i+4.;      //mu_innerTrack_Hits 4---17   num=14

		if(CT == 2) cutVal[i]=(double)i;        //mu_pixeLayers=0,1,2,3,4 num=5

		if(CT == 3) cutVal[i]=(double)i*2.;        //mu_nValidMuHits=0,2,4,...,18 num=10

		//cutVal[i]=(double)i*0.5+1.;  //mu_nchi2In 1.0, 1.5,...,6.5  num=12
		if(CT == 4) cutVal[i]=(double)i*0.2+1.;  //mu_nchi2In 1.0, 1.2,...,4  num=16

		if(CT == 5) 
		{
			if(i>1 && i<7) cutVal[i]=(double)(i-1)*0.2-0.1;   //mu_dxy 0.02,0.06,0.1,0.3,0.5,0.7,0.9,3.0  num=8
			if(i==0) cutVal[i]=0.02;
			if(i==1) cutVal[i]=0.06;
			if(i==7) cutVal[i]=3.0;
		}

		if(CT == 6) cutVal[i]=(double)i*2.+1.;     //mu_dz 1,3,5,...,19  num=10

		if(CT == 7) 
		{
			if(i==0) cutVal[i]=1.;
			if(i==1) cutVal[i]=1.5;
			if(i>=2 && i<=4) cutVal[i]=(double)i*2.-2.;
			if(i>=5) cutVal[i]=(double)i*4.-8.;  //nchi2Gl, 1., 1.5, 2., 4., 6., 12., 16., 20., 24, 28.. num=10;
		}

		if(CT == 8) 
		{
			if(i==0) cutVal[i]=0.001;
			if(i>0) cutVal[i]=(double)i*0.004+0.002;  //vProb 0.001,0.002,0.006,...,0.040  num=10
		}
		cout<<"===============cutVal: "<<cutVal[i]<<"================="<<endl;
	}


	char fileName[500];
	char name[100];
	char outName[500];
	sprintf(name,
			"runs148819-149182_MuOnia"
			);
	sprintf(outName,
			Form("/home/zhlinl/work/CMSSW_3_8_4/src/HeavyFlavorAnalysis/Onia2MuMu/test/macro/%s_%s.txt",name,cutVar));
	sprintf(fileName,
			"/home/zhlinl/cutAnalysis/test/macro/reducedTree.root"
			);
	//"fileName" is the Input TTree root file, generated by the "JPsiAnalyzerPAT.cc" in <HeavyFlavorAnalysis/Onia2MuMu>
	//you can simply configure "jpsianalyzerpat_cfg.py" to get it.  
	//the muon cut Variables are not included in the "JPsiAnalyzerPAT.cc", you neeed to add them yourself.

	ofstream outTxt(outName);
	ofstream dataFile(Form("%s.txt",cutVar));

	outTxt<<"cut Type: "<<cutVar<<endl;
	dataFile<<"cut Type "<<cutVar<<endl<<endl;
	for(int i=0; i<num; i++)
	{
		dataFile<<cutVal[i]<<" ";
	}
	dataFile<<endl<<endl;

	Double_t massMin,massMax;
	massMin=2.6;
	massMax=3.5;
	RooRealVar mass("mass","dimuon mass(GeV/c^{2})",massMin,massMax);

	RooDataSet *dataRaw[nBin];
	RooDataSet *data[nBin];

	for(int i=0; i<nBin; i++)
	{
		dataRaw[i]=new RooDataSet(Form("dataRaw%d",i),"data with no cut",mass);
		data[i]=new RooDataSet(Form("data%d",i),"signal+background",mass);
		//for(int j=0; j<nBin; j++)
		//{
		//	data[i][j]=new RooDataSet(Form("data%d%d",i,j),"signal+background",mass);
		//}
	}

	//Jpsi Variables
	Double_t JpsiMass,JpsiPt,JpsiRap;
	Double_t JpsiVprob;
	//(1).Positive Muon                                     
	double muPos_nchi2In, muPos_dxy, muPos_dz, muPos_nchi2Gl;
	int muPos_arbitrated, muPos_oneStationTight;
	int muPos_found, muPos_pixeLayers, muPos_nValidMuHits;
	//(2).Negative Muon                                     
	double muNeg_nchi2In, muNeg_dxy, muNeg_dz, muNeg_nchi2Gl;
	int muNeg_arbitrated, muNeg_oneStationTight;
	int muNeg_found, muNeg_pixeLayers, muNeg_nValidMuHits;
	//Trigger Information                                   
	int HLT_L1DoubleMuOpen, HLT_Mu0_TkMu0_Jpsi, HLT_Mu0_TkMu0_OST_Jpsi_Tight_v2;

	TFile *infile=new TFile(fileName,"R");
	TTree *tree=(TTree*)infile->Get("data");
	//Jpsi Variables
	tree->SetBranchAddress("JpsiMass",&JpsiMass);
	tree->SetBranchAddress("JpsiPt",&JpsiPt);
	tree->SetBranchAddress("JpsiRap",&JpsiRap);
	tree->SetBranchAddress("JpsiVprob",&JpsiVprob);
	//Trigger information
	tree->SetBranchAddress("HLT_L1DoubleMuOpen",&HLT_L1DoubleMuOpen);
	tree->SetBranchAddress("HLT_Mu0_TkMu0_Jpsi",&HLT_Mu0_TkMu0_Jpsi);
	tree->SetBranchAddress("HLT_Mu0_TkMu0_OST_Jpsi_Tight_v2",&HLT_Mu0_TkMu0_OST_Jpsi_Tight_v2);
	//1) Positive Muon                                      
	tree->SetBranchAddress("muPos_nchi2In", &muPos_nchi2In);
	tree->SetBranchAddress("muPos_dxy", &muPos_dxy);
	tree->SetBranchAddress("muPos_dz", &muPos_dz);
	tree->SetBranchAddress("muPos_nchi2Gl", &muPos_nchi2Gl);
	tree->SetBranchAddress("muPos_arbitrated", &muPos_arbitrated);
	tree->SetBranchAddress("muPos_oneStationTight", &muPos_oneStationTight);
	tree->SetBranchAddress("muPos_found", &muPos_found);
	tree->SetBranchAddress("muPos_pixeLayers", &muPos_pixeLayers);
	tree->SetBranchAddress("muPos_nValidMuHits", &muPos_nValidMuHits);
	//2) Negative Muon                                      
	tree->SetBranchAddress("muNeg_nchi2In", &muNeg_nchi2In);
	tree->SetBranchAddress("muNeg_dxy", &muNeg_dxy);
	tree->SetBranchAddress("muNeg_dz", &muNeg_dz);
	tree->SetBranchAddress("muNeg_nchi2Gl", &muNeg_nchi2Gl);
	tree->SetBranchAddress("muNeg_arbitrated", &muNeg_arbitrated);
	tree->SetBranchAddress("muNeg_oneStationTight", &muNeg_oneStationTight);
	tree->SetBranchAddress("muNeg_found", &muNeg_found);
	tree->SetBranchAddress("muNeg_pixeLayers", &muNeg_pixeLayers);
	tree->SetBranchAddress("muNeg_nValidMuHits", &muNeg_nValidMuHits);

	nEntries=tree->GetEntries();
	cout<<"===============total Entries in Tree: "<<nEntries<<"==============="<<endl;
	outTxt<<"===============total Entries in Tree: "<<nEntries<<"==============="<<endl;
	
	//these to initialize the parameters of mass distribution,see "fitPeak.cc"
	vector<double> sigBkg[nBin];
	Int_t nPeak=1; //signal peak number
	vector<Double_t> fMean,dfMean,fSigma,dfSigma;
	fMean.push_back(3.09); //Jpsi Mass mean
	dfMean.push_back(0.01); //deviation of mass mean
	fSigma.push_back(0.04); //Jpsi mass sigma
	dfSigma.push_back(0.04); //deviation of mass sigma

	cout<<"----------------------------------------------------------------------------------------"<<endl;
	cout<<"-----------------------starting Loop all the selection Cut------------------------------"<<endl;
	cout<<"----------------------------------------------------------------------------------------"<<endl;
	for(int k=0; k<num; k++)
	{
		cout<<endl<<"==================="<<cutVar<<" "<<k<<" Value: "<<cutVal[k]<<"==============="<<endl;
		//reset the dataset
		for(int i=0; i<nBin; i++)
		{
			data[i]->reset();
		}


		bool cutPass;
		for(int i=0; i<nEntries; i++)
		{
			tree->GetEntry(i);

			//-----------------------------define the Cut Variable----------------------
			if(CT == 1) cutPass = muPos_found > (int)cutVal[k] && muNeg_found > (int)cutVal[k] ;
			if(CT == 2) cutPass = muPos_pixeLayers > (int)cutVal[k] && muNeg_pixeLayers > (int)cutVal[k] ; 
			if(CT == 3) cutPass = (muPos_nValidMuHits < -100 || (muPos_nValidMuHits > -100 && muPos_nValidMuHits > (int)cutVal[k]))
				&& (muNeg_nValidMuHits < -100 || (muNeg_nValidMuHits > -100 && muNeg_nValidMuHits > (int)cutVal[k])); 
			if(CT == 4) cutPass =	muPos_nchi2In < cutVal[k]  && muNeg_nchi2In < cutVal[k] ;
			if(CT == 5) cutPass = fabs(muPos_dxy) < cutVal[k]  && fabs(muNeg_dxy) < cutVal[k] ;
			if(CT == 6) cutPass = fabs(muPos_dz) < cutVal[k]  && fabs(muNeg_dz) < cutVal[k] ;
			if(CT == 7) cutPass = (muPos_nchi2Gl < -100. || (muPos_nchi2Gl > -100. && muPos_nchi2Gl < cutVal[k] ))
				&& (muNeg_nchi2Gl < -100. || (muNeg_nchi2Gl > -100. && muNeg_nchi2Gl < cutVal[k] )) ;
			if(CT == 8) cutPass =	JpsiVprob > cutVal[k] ; 
			//--------------------------------------------------------------------------

			if( HLT_Mu0_TkMu0_OST_Jpsi_Tight_v2 == 1
					//&& JpsiMass>massMin && JpsiMass<massMax && JpsiPt>6. //this may be very slow to run, you can first use this Cut to make a compact root file, that would be fast. 
					&& muPos_arbitrated ==1 && muNeg_arbitrated ==1 
					&& muPos_oneStationTight ==1 && muNeg_oneStationTight ==1  
				)
			{	
				if(fabs(JpsiRap)<0.9 )
				{
					mass.setVal(JpsiMass);
					if(k==0) dataRaw[0]->add(mass);
					if(cutPass)
					{
						data[0]->add(mass);
						nData++;
					}
				}  
				if(fabs(JpsiRap)>0.9 && fabs(JpsiRap)<1.5)
				{
					mass.setVal(JpsiMass);
					if(k==0) dataRaw[1]->add(mass);
					if(cutPass)
					{
						data[1]->add(mass);
						nData++;
					}
				}
				if(fabs(JpsiRap)>1.5 && fabs(JpsiRap)<2.1)
				{
					mass.setVal(JpsiMass);
					if(k==0) dataRaw[2]->add(mass);
					if(cutPass)
					{
						data[2]->add(mass);
						nData++;
					}
				}
			}
		}
		
		if(k==0)
		{
			cout<<"======total matched Entries in Pt>6GeV && 0<|y|<2.1 : "<<nData<<" ======"<<endl;
			cout<<"======selected trigger path========: "<<"HLT_Mu0_TkMu0_OST_Jpsi_Tight_v2"<<"========"<<endl;
			outTxt<<"======total matched Entries in Pt>6GeV && 0<|y|<2.1 : "<<nData<<" ======"<<endl;
			outTxt<<"======selected trigger path========: "<<"HLT_Mu0_TkMu0_OST_Jpsi_Tight_v2"<<"========"<<endl;
		}

		TCanvas *c1[nBin];
		for(int i=0; i<nBin; i++)
		{
			c1[i]=new TCanvas(Form("c1_%d",i),"");
			c1[i]->SetFillColor(10);

			//SetMyStyle();
			gPad->SetLeftMargin(0.10);
			gPad->SetBottomMargin(0.10);
			gPad->SetRightMargin(0.10);
			gPad->SetTopMargin(0.10);

			sigBkg[i].clear();
			//fit the mass distribution in dataSet
			sigBkg[i]=fitPeak(mass,0,nPeak,0,data[i],fMean,dfMean,fSigma,dfSigma,0.5);
			//===========get the total number of sig && bkg in the cut value================
			nFoundSig[i][k]=sigBkg[i][4];
			nFoundBkg[i][k]=sigBkg[i][5];
			nFoundSigFull[i][k]=sigBkg[i][6];
			nFoundBkgFull[i][k]=sigBkg[i][5];
			//==============================================================================

			//------------Draw the Latex---------------
			Double_t left=0.12, top=0.83, textSize=0.033;
			TLatex *latex=new TLatex();
			latex->SetTextFont(42);
			latex->SetNDC(kTRUE);
			latex->SetTextSize(textSize);
			Double_t step=textSize*1.5;

			//===for int type cut
			if(CT <= 3) latex->DrawLatex(left,top,Form("%s>%d",cutVar,(int)cutVal[k]));
			//if(CT == 2) latex->DrawLatex(left,top,Form("%s>=%d",cutVar,(int)cutVal[k]));
			//===for double type cut
			if(CT >= 4) latex->DrawLatex(left,top,Form("%s<%.2f",cutVar,cutVal[k]));

			top-=step;
			if(i==0) latex->DrawLatex(left,top,Form("|y|<%.1f, P_{T}>%.1f",0.9,6.0));
			if(i==1) latex->DrawLatex(left,top,Form("%.1f<|y|<%.1f, P_{T}>%.1f",0.9,1.5,6.0));
			if(i==2) latex->DrawLatex(left,top,Form("%.1f<|y|<%.1f, P_{T}>%.1f",1.5,2.1,6.0));
			top-=step;
			latex->DrawLatex(left,top,"HLT_Mu0_TkMu0_OST_Jpsi_Tight_v2");
			top-=step;
			latex->DrawLatex(left,top,Form("S / B(#pm2.0#sigma_{M})= %.1f",sigBkg[i][2]));
			top-=step;
			latex->DrawLatex(left,top,Form("S / sqrt(S+B)(#pm2.0#sigma_{M})= %.1f",sigBkg[i][3]));

			c1[i]->Modified();
			c1[i]->Update();

			//===for int type cut
			if(CT <= 3) 
			{
				c1[i]->Print(Form("pic/%s/etaBin%d_%s%d.eps",cutVar,i,cutVar,(int)cutVal[k]));
				c1[i]->Print(Form("pic/%s/etaBin%d_%s%d.gif",cutVar,i,cutVar,(int)cutVal[k]));
			}
			//===for double type cut
			if(CT >=4)
			{
				c1[i]->Print(Form("pic/%s/etaBin%d_%s%d_cut%d.eps",cutVar,i,cutVar,(int)cutVal[k],k));
				c1[i]->Print(Form("pic/%s/etaBin%d_%s%d_cut%d.gif",cutVar,i,cutVar,(int)cutVal[k],k));
			}
		}
	}
	cout<<"----------------------------------------------------------------------------------------------"<<endl;
	cout<<"--------------------------------Loop on all cut DONE------------------------------------------"<<endl;
	cout<<"-----------------------------------------------------------------------------------------------"<<endl;

	vector<double> sigBkgRaw[nBin];
	TCanvas *c2[nBin];
	for(int i=0; i<nBin; i++)
	{
		c2[i]=new TCanvas(Form("c2_%d",i),"");
		sigBkgRaw[i].clear();
		//fit the mass to get the number of signal & bkg without CUT
		sigBkgRaw[i]=fitPeak(mass,0,nPeak,0,dataRaw[i],fMean,dfMean,fSigma,dfSigma,0.5);
		nFoundSigRaw[i]=(double)sigBkgRaw[i][6];
		nFoundBkgRaw[i]=(double)sigBkgRaw[i][5];
		cout<<"=============nFoundSigRaw "<<i<<" :"<<nFoundSigRaw[i]<<"================="<<endl;
		cout<<"=============nFoundBkgRaw "<<i<<" :"<<nFoundBkgRaw[i]<<"================="<<endl;
	}

	for(int k=0; k< num; k++)
	{
		cout<<"=============================="<<endl;
		cout<<"======Cut Value: "<<cutVal[k]<<"======="<<endl;
		cout<<"=============================="<<endl;
		outTxt<<"=============================="<<endl;
		outTxt<<"======Cut Value: "<<cutVal[k]<<"======="<<endl;
		outTxt<<"=============================="<<endl;

		for(int i=0; i<nBin; i++)
		{
			//compute the effSig & rejBkg
			if(nFoundSigRaw[i]!=0.)
				effSig[i][k]=nFoundSigFull[i][k]/nFoundSigRaw[i]*100.;  //"100" means change to percent
			if(nFoundBkgRaw[i]!=0)
				rejBkg[i][k]=(nFoundBkgRaw[i]-nFoundBkgFull[i][k])/nFoundBkgRaw[i]*100.;
			if(effSig[i][k] > 100.) effSig[i][k]=100.;
			if(nFoundSigRaw[i]==0.) effSig[i][k]=0.;
			if(rejBkg[i][k] < 0.) rejBkg[i][k] =0.;
			if(nFoundBkgRaw==0.) rejBkg[i][k] =100.;
			/*
			cout<<"===================================================================================="<<endl;
			cout<<"eta Bin "<<i<<" entries of signal(2sigma):"<<nFoundSig[i][k]<<endl;
			cout<<"eta Bin "<<i<<" entries of bkg(out4sigma):"<<nFoundBkg[i][k]<<endl;
			cout<<"eta Bin "<<i<<" entries of signalRaw:"<<nFoundSigRaw[i]<<endl;
			cout<<"eta Bin "<<i<<" entries of bkgRaw:"<<nFoundBkgRaw[i]<<endl;
			cout<<"eta Bin "<<i<<" entries of signalFull:"<<nFoundSigFull[i][k]<<endl;
			cout<<"eta Bin "<<i<<" entries of bkgFull:"<<nFoundBkgFull[i][k]<<endl;
			cout<<"eta Bin "<<i<<" efficency of signal(%):"<<effSig[i][k]<<endl;
			cout<<"eta Bin "<<i<<" rejection of bkg(%):"<<rejBkg[i][k]<<endl;
			cout<<endl;
			*/
			outTxt<<"===================================================================================="<<endl;
			outTxt<<"eta Bin "<<i<<" entries of signal(2sigma):"<<nFoundSig[i][k]<<endl;
			outTxt<<"eta Bin "<<i<<" entries of bkg(out4sigma):"<<nFoundBkg[i][k]<<endl;
			outTxt<<"eta Bin "<<i<<" entries of signalRaw:"<<nFoundSigRaw[i]<<endl;
			outTxt<<"eta Bin "<<i<<" entries of bkgRaw:"<<nFoundBkgRaw[i]<<endl;
			outTxt<<"eta Bin "<<i<<" entries of signalFull:"<<nFoundSigFull[i][k]<<endl;
			outTxt<<"eta Bin "<<i<<" entries of bkgFull:"<<nFoundBkgFull[i][k]<<endl;
			outTxt<<"eta Bin "<<i<<" efficency of signal(%):"<<effSig[i][k]<<endl;
			outTxt<<"eta Bin "<<i<<" rejection of bkg(%):"<<rejBkg[i][k]<<endl;
			outTxt<<endl;
		}
	}

	//generate a data file convenient to make data table
	for(int i=0; i<nBin; i++)
	{
		cout<<"eta Bin: "<<i<<endl;
		outTxt<<"eta Bin: "<<i<<endl;
		for(int j=0; j<num; j++)
		{
			cout<<"Cut Value: "<<cutVal[j]<<endl;
			cout<<"nFoundSig["<<i<<"]["<<j<<"]= "<<nFoundSig[i][j]<<endl;
			cout<<"nFoundBkg["<<i<<"]["<<j<<"]= "<<nFoundBkg[i][j]<<endl;

			outTxt<<"Cut Value: "<<cutVal[j]<<endl;
			outTxt<<"nFoundSig["<<i<<"]["<<j<<"]= "<<nFoundSig[i][j]<<endl;
			outTxt<<"nFoundBkg["<<i<<"]["<<j<<"]= "<<nFoundBkg[i][j]<<endl;

			dataFile<<"etaBin"<<i<<" eff "<<effSig[i][j]<<endl;
		}

		for(int j=0; j<num; j++)
		{
			dataFile<<"etaBin"<<i<<" rej "<<rejBkg[i][j]<<endl;
		}

		cout<<endl;
		outTxt<<endl;
		dataFile<<endl;
	}

	//draw the nFoundSig[nBin][num], nFoundBkg[nBin][num]
	TCanvas *c3[nBin];
	for(int i=0; i<nBin; i++)
	{

		//=================get Min and Max values  Y axis=======================
		double max=nFoundSig[i][0] ,min=nFoundBkg[i][0];
		for(int j=0; j<num; j++)
		{
			if(nFoundSig[i][j]>max) max=nFoundSig[i][j];
			if(nFoundBkg[i][j]<min) min=nFoundBkg[i][j];
		}
		//======================================================================
		c3[i]=new TCanvas(Form("c3_%d",i),"");
		c3[i]->SetFillColor(10);

		//SetMyStyle();
		gStyle->SetTitleXOffset(1.2); 
		gStyle->SetTitleYOffset(1.3); 
		gPad->SetLeftMargin(0.12);  
		gPad->SetBottomMargin(0.12);
		gPad->SetRightMargin(0.12); 
		gPad->SetTopMargin(0.12);  

		TGraph *foundS=new TGraph(num,cutVal,nFoundSig[i]);
		foundS->SetMarkerColor(2);
		foundS->SetMarkerStyle(21);
		foundS->SetMarkerSize(1.5);
		foundS->SetLineColor(2);
		foundS->GetXaxis()->SetTitle(cutVar);
		foundS->GetXaxis()->CenterTitle();
		foundS->GetYaxis()->SetTitle("Events");
		foundS->GetYaxis()->CenterTitle();

		TGraph *foundB=new TGraph(num,cutVal,nFoundBkg[i]);
		foundB->SetMarkerColor(4);
		foundB->SetMarkerStyle(23);
		foundB->SetMarkerSize(1.5);
		foundB->SetLineColor(4);

		if(i==0) foundS->SetTitle(Form("|y|<%.1f, P_{T}>%.1f",0.9,6.0));
		if(i==1) foundS->SetTitle(Form("%.1f<|y|<%.1f, P_{T}>%.1f",0.9,1.5,6.0));
		if(i==2) foundS->SetTitle(Form("%.1f<|y|<%.1f, P_{T}>%.1f",1.5,2.1,6.0));
		foundS->GetYaxis()->SetRangeUser(min-2000,max+3000);
		//you may need to change the values "2000" "3000", depend on the real events you get.
		foundS->Draw("ALP");
		foundB->Draw("PL");

		TLegend *leg = new TLegend(0.80,0.80,0.95,0.93);
		leg->AddEntry(foundS,"Nsignal","p");
		leg->AddEntry(foundB,"Nbackground","p");
		leg->Draw();
		c3[i]->Update();
		c3[i]->Print(Form("pic/%s/NsigBkg_etaBin%d.eps",cutVar,i));
		c3[i]->Print(Form("pic/%s/NsigBkg_etaBin%d.C",cutVar,i));
		c3[i]->Print(Form("pic/%s/NsigBkg_etaBin%d.gif",cutVar,i));
	}

	//draw effSig and rejBkg
	TCanvas *c4[nBin];
	for(int i=0; i<nBin; i++)
	{
		c4[i]=new TCanvas(Form("c4_%d",i),"");
		c4[i]->SetFillColor(10);

		//SetMyStyle();
		gStyle->SetTitleXOffset(1.2); 
		gStyle->SetTitleYOffset(1.3); 
		gPad->SetLeftMargin(0.12);  
		gPad->SetBottomMargin(0.12);
		gPad->SetRightMargin(0.12); 
		gPad->SetTopMargin(0.12); 

		TGraph *effSignal=new TGraph(num,cutVal,effSig[i]);
		effSignal->SetMarkerColor(2);
		effSignal->SetMarkerStyle(21);
		effSignal->SetMarkerSize(1.5);
		effSignal->SetLineColor(2);
		effSignal->GetXaxis()->SetTitle(cutVar);
		effSignal->GetXaxis()->CenterTitle();
		effSignal->GetYaxis()->SetTitle("efficency (%)");
		effSignal->GetYaxis()->CenterTitle();

		TGraph *rejBackground=new TGraph(num,cutVal,rejBkg[i]);
		rejBackground->SetMarkerColor(4);
		rejBackground->SetMarkerStyle(23);
		rejBackground->SetMarkerSize(1.5);
		rejBackground->SetLineColor(4);

		if(i==0) effSignal->SetTitle(Form("|y|<%.1f, P_{T}>%.1f",0.9,6.0));
		if(i==1) effSignal->SetTitle(Form("%.1f<|y|<%.1f, P_{T}>%.1f",0.9,1.5,6.0));
		if(i==2) effSignal->SetTitle(Form("%.1f<|y|<%.1f, P_{T}>%.1f",1.5,2.1,6.0));
		effSignal->GetYaxis()->SetRangeUser(0.,120.);
		effSignal->Draw("ALP");
		rejBackground->Draw("PL");

		TLegend *leg = new TLegend(0.80,0.80,0.95,0.93);
		leg->AddEntry(effSignal,"effSig","p");
		leg->AddEntry(rejBackground,"rejectBkg","p");
		leg->Draw();
		c4[i]->Update();
		c4[i]->Print(Form("pic/%s/EffRejec_etaBin%d.eps",cutVar,i));
		c4[i]->Print(Form("pic/%s/EffRejec_etaBin%d.C",cutVar,i));
		c4[i]->Print(Form("pic/%s/EffRejec_etaBin%d.gif",cutVar,i));
	}

	outTxt.close();
	dataFile.close();

	return;

}


